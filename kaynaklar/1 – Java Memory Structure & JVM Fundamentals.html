<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance Optimized Java Development - Bölüm 1</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(45deg, #2c3e50, #34495e);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
        }
        
        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
            margin-top: 10px;
        }
        
        .content {
            padding: 40px;
        }
        
        .slide {
            margin-bottom: 60px;
            background: #f8f9fa;
            border-radius: 12px;
            padding: 30px;
            border-left: 5px solid #3498db;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
        }
        
        .slide h2 {
            color: #2c3e50;
            font-size: 2em;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
        }
        
        .slide h3 {
            color: #34495e;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        
        .emoji {
            font-size: 1.2em;
            margin-right: 15px;
        }
        
        .highlight {
            background: linear-gradient(120deg, #a8e6cf 0%, #dcedc1 100%);
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #27ae60;
        }
        
        .warning {
            background: linear-gradient(120deg, #ffd3a5 0%, #fd9853 100%);
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #f39c12;
        }
        
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 25px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            margin: 20px 0;
            overflow-x: auto;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.3);
        }
        
        .code-header {
            color: #3498db;
            font-weight: bold;
            margin-bottom: 15px;
            font-size: 1.1em;
        }
        
        .performance-tip {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
            color: black;
        }
        
        .before, .after {
            padding: 20px;
            border-radius: 8px;
        }
        
        .before {
            background: #ffebee;
            border-left: 4px solid #e74c3c;
        }
        
        .after {
            background: #e8f5e8;
            border-left: 4px solid #27ae60;
        }
        
        .tools-section {
            background: #f1f2f6;
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
        }
        
        .metric-box {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin: 10px 0;
            color: black;
        }
        
        ul {
            padding-left: 20px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        .demo-section {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin: 30px 0;
        }
        
        @media (max-width: 768px) {
            .comparison {
                grid-template-columns: 1fr;
            }
            
            .container {
                margin: 10px;
                border-radius: 10px;
            }
            
            .content {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Performance Optimized Java Development</h1>
            <div class="subtitle">Bölüm 1: Java Memory Structure & JVM Fundamentals</div>
            <div class="subtitle">Spring Boot 3.5.5 - IntelliJ IDEA Ultimate</div>
        </div>
        
        <div class="content">
            <!-- Slide 1: JVM Memory Model -->
            <div class="slide">
                <h2><span class="emoji">🧠</span>JVM Memory Model Nedir?</h2>
                
                <p>JVM Memory Model, Java uygulamalarının bellek yönetiminin temelini oluşturur. Performans optimizasyonu için bu yapıyı derinlemesine anlamak kritiktir.</p>
                
                <h3>JVM Memory Alanları</h3>
                
                <div class="highlight">
                    <h4>🎯 Performans Etkisi</h4>
                    <p>JVM memory model anlayışı, uygulamanızın <strong>%40-60</strong> daha verimli çalışmasını sağlayabilir!</p>
                </div>
                
                <div class="code-block">
                    <div class="code-header">JVM Memory Layout</div>
                    <pre>
┌─────────────────────────────────────┐
│            JVM Memory               │
├─────────────────────────────────────┤
│  Heap Memory (Young + Old Gen)     │ ← Object Storage
│  Stack Memory (Thread Local)       │ ← Method Calls & Local Variables  
│  Metaspace (Class Metadata)        │ ← Class Information
│  Code Cache (Compiled Code)        │ ← JIT Optimized Code
│  Direct Memory (NIO Buffers)       │ ← Off-Heap Storage
└─────────────────────────────────────┘
                    </pre>
                </div>
                
                <div class="tools-section">
                    <h4>📊 İzleme Araçları</h4>
                    <div class="metric-box">
                        <strong>IntelliJ IDEA Ultimate:</strong> Memory profiler built-in
                    </div>
                    <div class="metric-box">
                        <strong>JVisualVM:</strong> Real-time memory monitoring
                    </div>
                    <div class="metric-box">
                        <strong>Spring Boot Actuator:</strong> /actuator/metrics/jvm.memory.*
                    </div>
                </div>
            </div>

            <!-- Slide 2: Stack vs Heap -->
            <div class="slide">
                <h2><span class="emoji">⚖️</span>Stack vs Heap Farkı</h2>
                
                <div class="comparison">
                    <div class="before">
                        <h4>🗃️ Stack Memory</h4>
                        <ul>
                            <li><strong>Hızlı:</strong> LIFO (Last In, First Out)</li>
                            <li><strong>Thread-safe:</strong> Her thread'in kendi stack'i</li>
                            <li><strong>Otomatik temizlik:</strong> Method bitince temizlenir</li>
                            <li><strong>Sınırlı boyut:</strong> StackOverflowError riski</li>
                            <li><strong>Primitive türler ve referanslar</strong></li>
                        </ul>
                    </div>
                    <div class="after">
                        <h4>🏗️ Heap Memory</h4>
                        <ul>
                            <li><strong>Esnek:</strong> Dynamic allocation</li>
                            <li><strong>Paylaşımlı:</strong> Tüm thread'ler erişebilir</li>
                            <li><strong>GC gerekli:</strong> Garbage Collector temizler</li>
                            <li><strong>Büyük boyut:</strong> OutOfMemoryError riski</li>
                            <li><strong>Object instances</strong></li>
                        </ul>
                    </div>
                </div>
                
                <div class="warning">
                    <h4>⚠️ Performans Tuzakları</h4>
                    <p><strong>Stack Overflow:</strong> Çok derin recursion (-Xss parametresi ile kontrol)</p>
                    <p><strong>Heap Exhaustion:</strong> Memory leak'ler (-Xmx parametresi ile kontrol)</p>
                </div>
                
                <div class="code-block">
                    <div class="code-header">Stack vs Heap Example</div>
                    <pre>
public class MemoryExample {
    private List&lt;String&gt; heapList = new ArrayList&lt;&gt;(); // Heap'te saklanır
    
    public void stackVsHeapDemo() {
        int localVar = 100;           // Stack'te saklanır
        String localString = "test";  // Reference Stack'te, Object Heap'te
        
        // Method çağrısı - Stack frame oluşturur
        processData(localVar);
    }
    
    private void processData(int param) {  // param Stack'te
        StringBuilder sb = new StringBuilder(); // sb reference Stack'te, Object Heap'te
        // Method bitince Stack frame temizlenir
    }
}
                    </pre>
                </div>
            </div>

            <!-- Slide 3: Metaspace ve ClassLoader Leak -->
            <div class="slide">
                <h2><span class="emoji">🔄</span>Metaspace ve ClassLoader Leak Senaryoları</h2>
                
                <p>Java 8'den sonra PermGen yerine Metaspace kullanılır. ClassLoader leak'ler ciddi memory sorunlarına yol açabilir.</p>
                
                <div class="highlight">
                    <h4>🎯 Kritik Performans Noktası</h4>
                    <p>ClassLoader leak'ler <strong>prod ortamında</strong> en yaygın OutOfMemoryError sebebidir!</p>
                </div>
                
                <h3>Metaspace Yapısı</h3>
                <div class="code-block">
                    <div class="code-header">Metaspace İçeriği</div>
                    <pre>
Metaspace:
├── Class metadata (method bytecode, field info)
├── Runtime constant pool
├── Method area data
└── ClassLoader references

Memory Allocation:
- Young Generation → Eden + Survivor spaces
- Old Generation → Long-lived objects  
- Metaspace → Class definitions (Native memory'de)
                    </pre>
                </div>
                
                <h3>ClassLoader Leak Senaryoları</h3>
                
                <div class="comparison">
                    <div class="before">
                        <h4>❌ Leak Yapan Kod</h4>
                        <div class="code-block">
                            <pre>
@RestController
public class LeakyController {
    // Static collection - GC edilmez!
    private static final List&lt;Object&gt; STATIC_CACHE = new ArrayList&lt;&gt;();
    
    @GetMapping("/leak")
    public String createLeak() {
        // Her request'te static collection büyür
        STATIC_CACHE.add(new LargeObject());
        return "Leak created: " + STATIC_CACHE.size();
    }
}
                            </pre>
                        </div>
                    </div>
                    <div class="after">
                        <h4>✅ Leak-Free Kod</h4>
                        <div class="code-block">
                            <pre>
@RestController  
public class SafeController {
    // WeakHashMap kullan veya cache TTL ekle
    private final Map&lt;String, Object&gt; cache = new WeakHashMap&lt;&gt;();
    
    @GetMapping("/safe")
    public String createSafe() {
        String key = "key_" + System.currentTimeMillis();
        cache.put(key, new LargeObject());
        return "Safe operation: " + cache.size();
    }
}
                            </pre>
                        </div>
                    </div>
                </div>
                
                <div class="tools-section">
                    <h4>🔍 ClassLoader Leak Tespiti</h4>
                    <div class="metric-box">
                        <strong>IntelliJ Memory Profiler:</strong> ClassLoader instances takibi
                    </div>
                    <div class="metric-box">
                        <strong>Eclipse MAT:</strong> Heap dump analizi
                    </div>
                    <div class="metric-box">
                        <strong>JVM Arguments:</strong> -XX:+TraceClassLoading -XX:+TraceClassUnloading
                    </div>
                </div>
            </div>

            <!-- Slide 4: Code Cache & JIT -->
            <div class="slide">
                <h2><span class="emoji">⚡</span>Code Cache & JIT Compiler Optimizasyonları</h2>
                
                <p>JIT (Just-In-Time) compiler, runtime'da bytecode'u native machine code'a çevirir. Code Cache bu optimizasyonları saklar.</p>
                
                <div class="performance-tip">
                    <h4>🚀 Performans Artışı</h4>
                    <p>JIT optimizasyonları uygulamanızı <strong>10-100x</strong> hızlandırabilir!</p>
                </div>
                
                <h3>JIT Compilation Levels</h3>
                <div class="code-block">
                    <div class="code-header">Compilation Seviyeleri</div>
                    <pre>
Level 0: Interpreted mode (bytecode execution)
Level 1: C1 compiler - simple optimizations  
Level 2: C1 compiler - invocation & back-edge counters
Level 3: C1 compiler - full profiling
Level 4: C2 compiler - aggressive optimizations

JIT Triggers:
- Method invoke count > 10,000 (server mode)
- Loop iteration count > 10,000  
- Hot code path detection
                    </pre>
                </div>
                
                <div class="comparison">
                    <div class="before">
                        <h4>❌ JIT-Unfriendly Kod</h4>
                        <div class="code-block">
                            <pre>
@RestController
public class UnoptimizedController {
    
    @GetMapping("/slow")
    public ResponseEntity&lt;String&gt; slowMethod() {
        // Polymorphic calls - JIT'i zorlar
        List&lt;Object&gt; mixed = Arrays.asList("string", 123, 45.67);
        
        StringBuilder result = new StringBuilder();
        for (Object obj : mixed) {
            // Type checking her seferinde
            result.append(obj.toString()).append(",");
        }
        
        return ResponseEntity.ok(result.toString());
    }
}
                            </pre>
                        </div>
                    </div>
                    <div class="after">
                        <h4>✅ JIT-Optimized Kod</h4>
                        <div class="code-block">
                            <pre>
@RestController
public class OptimizedController {
    
    @GetMapping("/fast")
    public ResponseEntity&lt;String&gt; fastMethod() {
        // Monomorphic calls - JIT inline yapabilir
        List&lt;String&gt; strings = Arrays.asList("data1", "data2", "data3");
        
        // StringBuilder capacity pre-allocation
        StringBuilder result = new StringBuilder(64);
        for (String str : strings) {
            result.append(str).append(",");
        }
        
        return ResponseEntity.ok(result.toString());
    }
}
                            </pre>
                        </div>
                    </div>
                </div>
                
                <div class="tools-section">
                    <h4>🔧 JIT Monitoring</h4>
                    <div class="metric-box">
                        <strong>JVM Flags:</strong> -XX:+PrintCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining
                    </div>
                    <div class="metric-box">
                        <strong>Code Cache Size:</strong> -XX:ReservedCodeCacheSize=256M
                    </div>
                    <div class="metric-box">
                        <strong>IntelliJ Profiler:</strong> Method compilation tracking
                    </div>
                </div>
            </div>

            <!-- Slide 5: Spring Boot Memory -->
            <div class="slide">
                <h2><span class="emoji">🍃</span>Spring Boot Uygulamalarında Memory Tüketimi</h2>
                
                <p>Spring Boot uygulamaları özel memory patterns'lere sahiptir. Auto-configuration, bean lifecycle, ve AOP proxy'ler memory tüketimini etkiler.</p>
                
                <div class="highlight">
                    <h4>📈 Spring Boot Memory Hotspots</h4>
                    <ul>
                        <li><strong>Bean Creation:</strong> ApplicationContext initialization</li>
                        <li><strong>Auto-Configuration:</strong> Conditional bean loading</li>
                        <li><strong>AOP Proxies:</strong> Dynamic proxy generation</li>
                        <li><strong>Connection Pools:</strong> Database/HTTP connection management</li>
                    </ul>
                </div>
                
                <h3>Spring Boot Memory Configuration</h3>
                <div class="code-block">
                    <div class="code-header">application.yml - Memory Tuning</div>
                    <pre>
server:
  tomcat:
    max-threads: 200        # Thread pool size
    max-connections: 8192   # Connection limit
    connection-timeout: 20000

spring:
  datasource:
    hikari:
      maximum-pool-size: 10      # DB connection pool
      minimum-idle: 5
      connection-timeout: 30000
      
  jpa:
    hibernate:
      ddl-auto: none
    show-sql: false              # Production'da false!
    properties:
      hibernate:
        jdbc.batch_size: 20      # Batch operations
        cache.use_second_level_cache: true
                    </pre>
                </div>
                
                <div class="comparison">
                    <div class="before">
                        <h4>❌ Memory Hungry Spring Boot</h4>
                        <div class="code-block">
                            <pre>
@RestController
public class MemoryHungryController {
    
    @Autowired
    private EntityManager entityManager;
    
    @GetMapping("/hungry")
    public List&lt;User&gt; getAllUsers() {
        // N+1 query problem
        List&lt;User&gt; users = entityManager
            .createQuery("SELECT u FROM User u", User.class)
            .getResultList();
            
        // Lazy loading trigger - memory spike
        for (User user : users) {
            user.getOrders().size(); // Each access = new query
        }
        
        return users; // Large object graph in memory
    }
}
                            </pre>
                        </div>
                    </div>
                    <div class="after">
                        <h4>✅ Memory Efficient Spring Boot</h4>
                        <div class="code-block">
                            <pre>
@RestController
public class MemoryEfficientController {
    
    @Autowired
    private UserRepository userRepository;
    
    @GetMapping("/efficient")
    public Page&lt;UserDTO&gt; getUsers(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "20") int size) {
        
        // Pagination - small memory footprint
        Pageable pageable = PageRequest.of(page, size);
        
        // DTO projection - only needed fields
        return userRepository.findAllProjectedBy(pageable)
            .map(this::toDTO);
    }
    
    private UserDTO toDTO(User user) {
        return UserDTO.builder()
            .id(user.getId())
            .name(user.getName())
            .build();
    }
}
                            </pre>
                        </div>
                    </div>
                </div>
                
                <div class="performance-tip">
                    <h4>🎯 Spring Boot Memory Best Practices</h4>
                    <ul>
                        <li><strong>@Lazy annotation:</strong> Bean'leri gerektiğinde yükle</li>
                        <li><strong>@Conditional annotations:</strong> Gereksiz bean'leri önle</li>
                        <li><strong>Connection pooling:</strong> HikariCP optimization</li>
                        <li><strong>Cache strategy:</strong> @Cacheable ile memory-efficient caching</li>
                    </ul>
                </div>
            </div>

            <!-- Demo Section -->
            <div class="demo-section">
                <h2><span class="emoji">💻</span>Demo Senaryosu: Memory Leak Detection</h2>
                
                <h3>🎯 Demo Hedefi</h3>
                <p>Basit bir REST API üzerinden memory leak oluşturup, Spring Boot Actuator ile izleme</p>
                
                <div class="code-block">
                    <div class="code-header">1. Dependencies (pom.xml)</div>
                    <pre>
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;io.micrometer&lt;/groupId&gt;
        &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
                    </pre>
                </div>
                
                <div class="code-block">
                    <div class="code-header">2. Memory Leak Controller</div>
                    <pre>
@RestController
@RequestMapping("/memory")
public class MemoryLeakDemoController {
    
    private static final List&lt;byte[]&gt; MEMORY_LEAK_LIST = new ArrayList&lt;&gt;();
    
    @GetMapping("/leak/{size}")
    public ResponseEntity&lt;String&gt; createMemoryLeak(@PathVariable int size) {
        // Her request'te 1MB memory allocate et
        byte[] memoryChunk = new byte[size * 1024 * 1024];
        Arrays.fill(memoryChunk, (byte) 1);
        MEMORY_LEAK_LIST.add(memoryChunk);
        
        return ResponseEntity.ok("Memory leak created. Total chunks: " + MEMORY_LEAK_LIST.size());
    }
    
    @GetMapping("/clear")
    public ResponseEntity&lt;String&gt; clearMemory() {
        MEMORY_LEAK_LIST.clear();
        System.gc(); // Force garbage collection (production'da kullanma!)
        return ResponseEntity.ok("Memory cleared");
    }
    
    @GetMapping("/status")
    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; getMemoryStatus() {
        Runtime runtime = Runtime.getRuntime();
        Map&lt;String, Object&gt; memoryInfo = new HashMap&lt;&gt;();
        
        memoryInfo.put("totalMemory", runtime.totalMemory() / 1024 / 1024 + " MB");
        memoryInfo.put("freeMemory", runtime.freeMemory() / 1024 / 1024 + " MB");
        memoryInfo.put("usedMemory", (runtime.totalMemory() - runtime.freeMemory()) / 1024 / 1024 + " MB");
        memoryInfo.put("maxMemory", runtime.maxMemory() / 1024 / 1024 + " MB");
        memoryInfo.put("leakListSize", MEMORY_LEAK_LIST.size());
        
        return ResponseEntity.ok(memoryInfo);
    }
}
                    </pre>
                </div>
                
                <div class="code-block">
                    <div class="code-header">3. Actuator Configuration (application.yml)</div>
                    <pre>
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      show-details: always
  metrics:
    export:
      prometheus:
        enabled: true

spring:
  application:
    name: memory-leak-demo
    
# JVM startup parameters
# -Xms512m -Xmx1024m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/
                    </pre>
                </div>
                
                <h3>🔍 Demo Test Adımları</h3>
                
                <div class="metric-box">
                    <h4>1. Baseline Memory Ölçümü</h4>
                    <p><strong>URL:</strong> http://localhost:8080/actuator/metrics/jvm.memory.used</p>
                    <p><strong>Endpoint:</strong> GET /memory/status</p>
                </div>
                
                <div class="metric-box">
                    <h4>2. Memory Leak Oluşturma</h4>
                    <p><strong>Test:</strong> GET /memory/leak/10 (10MB allocate)</p>
                    <p><strong>Tekrar:</strong> 5-10 kez çağır</p>
                </div>
                
                <div class="metric-box">
                    <h4>3. Memory Monitoring</h4>
                    <p><strong>Actuator:</strong> /actuator/metrics/jvm.memory.used?tag=area:heap</p>
                    <p><strong>IntelliJ:</strong> Run → Profile → Memory profiler</p>
                </div>
                
                <div class="metric-box">
                    <h4>4. GC Impact Analysis</h4>
                    <p><strong>Metrics:</strong> /actuator/metrics/jvm.gc.pause</p>
                    <p><strong>JVM Args:</strong> -XX:+PrintGC -XX:+PrintGCDetails</p>
                </div>
                
                <h3>📊 Beklenen Sonuçlar</h3>
                
                <div class="comparison">
                    <div class="before">
                        <h4>❌ Öncesi (Normal Durum)</h4>
                        <ul>
                            <li>Heap usage: ~50-100MB</li>
                            <li>GC frequency: Düşük</li>
                            <li>Response time: <50ms</li>
                        </ul>
                    </div>
                    <div class="after">
                        <h4>⚠️ Sonrası (Memory Leak)</h4>
                        <ul>
                            <li>Heap usage: 500MB+</li>
                            <li>GC frequency: Yüksek</li>
                            <li>Response time: 200ms+</li>
                            <li>OutOfMemoryError riski</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <div class="tools-section">
                <h2>🛠️ Kullanılacak Araçlar ve Test Süreci</h2>
                
                <h3>IntelliJ IDEA Ultimate Tools</h3>
                <div class="metric-box">
                    <strong>Built-in Profiler:</strong> Run → Profile → CPU/Memory Profiler
                </div>
                <div class="metric-box">
                    <strong>JVM Debug:</strong> VM options: -Xms512m -Xmx1024m -XX:+HeapDumpOnOutOfMemoryError
                </div>
                <div class="metric-box">
                    <strong>HTTP Client:</strong> .http files ile endpoint testing
                </div>
                
                <h3>External Tools</h3>
                <div class="metric-box">
                    <strong>JVisualVM:</strong> Real-time memory, CPU, thread monitoring
                </div>
                <div class="metric-box">
                    <strong>Eclipse MAT:</strong> Heap dump analysis (memory leak detection)
                </div>
                <div class="metric-box">
                