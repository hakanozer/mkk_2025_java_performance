<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bölüm 5 – Java Application Performance in Clustered Environments</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h1 {
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            background-color: #ecf0f1;
            padding: 8px 12px;
            border-left: 5px solid #3498db;
            margin-top: 30px;
        }
        .slide-title {
            background-color: #2c3e50;
            color: white;
            padding: 12px;
            border-radius: 5px;
            margin: 25px 0 15px 0;
        }
        .important {
            background-color: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        .performance-impact {
            background-color: #d4edda;
            border-left: 5px solid #28a745;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }
        .before-after {
            display: flex;
            gap: 20px;
            margin: 30px 0;
        }
        .before, .after {
            flex: 1;
            padding: 20px;
            border-radius: 8px;
        }
        .before {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
        }
        .after {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
        }
        .code-block {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            margin: 15px 0;
        }
        ul, ol {
            padding-left: 20px;
        }
        li {
            margin-bottom: 8px;
        }
        .demo-section {
            background-color: #e8f4fc;
            padding: 20px;
            border-radius: 8px;
            margin: 25px 0;
            border: 1px solid #b3d7ff;
        }
        .step {
            font-weight: bold;
            color: #2980b9;
        }
    </style>
</head>
<body>

<h1>Bölüm 5 – Java Application Performance in Clustered Environments</h1>

<div class="slide-title">Clustered mimariler: Horizontal scaling, multiple JVM</div>

<p>Modern uygulamalar, yüksek erişilebilirlik ve yük dengeleme için genellikle birden fazla JVM instance üzerinde çalıştırılır. Horizontal scaling, tek bir sunucunun kapasitesini aşan yükleri dağıtmak için kritik bir stratejidir.</p>

<div class="important">
    <strong>ÖNEMLİ VURGU:</strong> Birden fazla JVM üzerinde çalışan bir uygulama, stateless (durumsuz) tasarlanmalıdır. Aksi takdirde, session verileri veya shared state nedeniyle tutarsızlıklar ve performans kayıpları yaşanır.
</div>

<div class="performance-impact">
    <strong>PERFORMANS ETKİSİ:</strong> Horizontal scaling, doğru yapılandırıldığında sistemin toplam kapasitesini doğrusal olarak artırır. Ancak stateful (durumlu) yapılar, network hop'ları ve veri eşitleme maliyetleri nedeniyle ölçeklenebilirliği bozar ve gecikmeyi artırır.
</div>

<div class="before-after">
    <div class="before">
        <h3>ÖNCE: Tek Instance (Monolitik)</h3>
        <ul>
            <li>Tüm kullanıcılar tek JVM üzerinde servis edilir.</li>
            <li>Session verisi bellekte tutulur (in-memory).</li>
            <li>Yük arttığında JVM GC baskısı ve thread rekabeti artar.</li>
            <li>Failover yoktur — tek nokta hata riski yüksektir.</li>
            <li><strong>Performans:</strong> Yüksek trafikte yanıt süreleri katlanarak artar, hizmet kesintisi riski.</li>
        </ul>
    </div>
    <div class="after">
        <h3>SONRA: Çoklu Instance (Clustered)</h3>
        <ul>
            <li>Yük dengeleyici (Load Balancer) gelen istekleri dağıtır.</li>
            <li>Her instance stateless — session verisi merkezi bir depoda tutulur.</li>
            <li>Failover mekanizması — bir instance çökerse diğerleri devreye girer.</li>
            <li><strong>Performans:</strong> Trafik artsa bile yanıt süreleri sabit kalır, sistemin toplam kapasitesi artar.</li>
        </ul>
    </div>
</div>

<div class="slide-title">Session replication sorunları</div>

<p>Geleneksel yaklaşımlarda, session verisi bir instance’tan diğerine çoğaltılır (replicate). Bu, network trafiği, bellek tüketimi ve tutarlılık sorunlarına yol açar.</p>

<div class="important">
    <strong>ÖNEMLİ VURGU:</strong> Session replication, CAP teoremine göre consistency ve availability arasında bir ödünleşim zorunluluğu yaratır. Özellikle yüksek trafikli sistemlerde network bottleneck oluşturur.
</div>

<div class="performance-impact">
    <strong>PERFORMANS ETKİSİ:</strong> Session replication, her HTTP isteğinden sonra network üzerinden veri senkronizasyonu gerektirir. Bu, latency’yi artırır ve ölçeklenebilirliği sınırlar. Büyük session verileri durumunda etki katlanarak artar.
</div>

<div class="before-after">
    <div class="before">
        <h3>ÖNCE: Session Replication</h3>
        <ul>
            <li>Her instance, diğerlerinin session verisini tutar.</li>
            <li>Session güncellendiğinde tüm node’lara broadcast yapılır.</li>
            <li>Network trafiği ve CPU kullanımı yüksek.</li>
            <li>Tutarlılık sorunları (eventual consistency).</li>
            <li><strong>Performans:</strong> 1000 kullanıcıda 300ms gecikme → 10.000 kullanıcıda 2500ms gecikme.</li>
        </ul>
    </div>
    <div class="after">
        <h3>SONRA: External Session Store (Redis)</h3>
        <ul>
            <li>Session verisi Redis gibi harici bir key-value store’da tutulur.</li>
            <li>Her instance sadece gerektiğinde session verisini okur/yazar.</li>
            <li>Network trafiği minimumda, sadece okuma/yazma işlemleri.</li>
            <li>Tek kaynaklı tutarlılık (strong consistency).</li>
            <li><strong>Performans:</strong> 10.000 kullanıcıda bile ortalama 50-100ms yanıt süresi korunur.</li>
        </ul>
    </div>
</div>

<div class="slide-title">Distributed locks</div>

<p>Clustered ortamlarda, aynı kaynağı (örneğin: stok güncelleme, sıra numarası üretimi) birden fazla instance aynı anda değiştirmeye çalışabilir. Bu durumda race condition ve veri tutarsızlığı riski doğar. Distributed lock mekanizmaları bu sorunu çözer.</p>

<div class="important">
    <strong>ÖNEMLİ VURGU:</strong> JVM içi (in-JVM) synchronized veya ReentrantLock yapıları sadece tek JVM içinde çalışır. Clustered ortamda geçersizdir. Mutlaka dağıtık kilit mekanizması kullanılmalıdır.
</div>

<div class="performance-impact">
    <strong>PERFORMANS ETKİSİ:</strong> Distributed lock, network üzerinden koordinasyon gerektirdiği için ek gecikme yaratır. Ancak bu gecikme, veri tutarsızlığının maliyetinden çok daha düşüktür. İyi tasarlanmış lock scope ve TTL ile performans etkisi minimize edilebilir.
</div>

<div class="slide-title">Network latency problemleri</div>

<p>Clustered mimarilerde, instance’lar arası iletişim ve harici servislerle (Redis, DB, Cache) yapılan çağrılar network gecikmesine (latency) maruz kalır. Bu gecikmeler, özellikle yüksek trafikte kümülatif olarak sistemin genel performansını düşürür.</p>

<div class="important">
    <strong>ÖNEMLİ VURGU:</strong> Network latency, “beklenen” bir maliyettir ama optimize edilebilir. Connection pooling, async çağrılar, cache ön bellekleme ve co-location (aynı veri merkezinde deploy) gibi stratejilerle etkisi azaltılabilir.
</div>

<div class="performance-impact">
    <strong>PERFORMANS ETKİSİ:</strong> Her Redis erişimi 2-5ms ekleyebilir. 10 adımlı bir iş akışında bu 20-50ms’e ulaşabilir. Bu nedenle gereksiz çağrılar minimize edilmeli, batch işlemleri tercih edilmelidir.
</div>

<div class="demo-section">
    <h2>💻 Demo Senaryosu: Spring Boot 3.5.5 + Redis Session + Redisson Distributed Lock</h2>
    <p><strong>Hedef:</strong> İki Spring Boot instance’ı aynı kullanıcı session’ını paylaşacak ve kritik bir kaynağı distributed lock ile koruyacak.</p>

    <h3>Adım 1: Proje Kurulumu (IntelliJ IDEA Ultimate)</h3>
    <ul>
        <li>Spring Initializr ile yeni proje oluşturun:
            <ul>
                <li>Spring Boot: 3.5.5</li>
                <li>Dependencies: Spring Web, Spring Session Data Redis, Spring Data Redis, Redisson</li>
            </ul>
        </li>
        <li><code>application.properties</code> dosyasını yapılandırın:
            <div class="code-block">
server.port=8080
spring.redis.host=localhost
spring.redis.port=6379
spring.session.store-type=redis
spring.session.timeout=1800s
            </div>
        </li>
    </ul>

    <h3>Adım 2: RedisSession Konfigürasyonu</h3>
    <p>Session verisinin Redis’te saklanmasını sağlar. Her iki instance da aynı Redis’e bağlanacağı için session paylaşımı otomatik sağlanır.</p>
    <div class="code-block">
@Configuration
@EnableRedisHttpSession
public class SessionConfig {
    @Bean
    public LettuceConnectionFactory connectionFactory() {
        return new LettuceConnectionFactory();
    }
}
    </div>

    <h3>Adım 3: Redisson Distributed Lock Konfigürasyonu</h3>
    <div class="code-block">
@Configuration
public class RedissonConfig {
    
    @Value("${spring.redis.host}")
    private String redisHost;
    
    @Value("${spring.redis.port}")
    private int redisPort;

    @Bean(destroyMethod = "shutdown")
    public RedissonClient redissonClient() {
        Config config = new Config();
        config.useSingleServer()
              .setAddress("redis://" + redisHost + ":" + redisPort);
        return Redisson.create(config);
    }
}
    </div>

    <h3>Adım 4: Kritik Kaynağa Erişim (Distributed Lock Kullanarak)</h3>
    <div class="code-block">
@RestController
public class InventoryController {
    
    @Autowired
    private RedissonClient redissonClient;
    
    private int stock = 100; // paylaşılan kaynak

    @PostMapping("/buy")
    public ResponseEntity<String> buyItem(@RequestBody PurchaseRequest request) {
        String lockKey = "inventory:lock:item:" + request.getItemId();
        RLock lock = redissonClient.getLock(lockKey);
        
        try {
            boolean acquired = lock.tryLock(3, 10, TimeUnit.SECONDS);
            if (!acquired) {
                return ResponseEntity.status(429).body("Too many requests, try again later");
            }
            
            // Kritik bölge: stok kontrol ve güncelleme
            if (stock >= request.getQuantity()) {
                stock -= request.getQuantity();
                return ResponseEntity.ok("Purchase successful. Remaining stock: " + stock);
            } else {
                return ResponseEntity.badRequest().body("Insufficient stock");
            }
            
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return ResponseEntity.status(500).body("Operation interrupted");
        } finally {
            lock.unlock();
        }
    }
}
    </div>

    <h3>Adım 5: Test ve Gözlem</h3>
    <ul>
        <li><span class="step">1.</span> Redis sunucusunu başlatın: <code>redis-server</code></li>
        <li><span class="step">2.</span> Projeyi iki farklı portta çalıştırın:
            <div class="code-block">
# Terminal 1
./gradlew bootRun --args='--server.port=8080'

# Terminal 2
./gradlew bootRun --args='--server.port=8081'
            </div>
        </li>
        <li><span class="step">3.</span> Postman veya curl ile aynı kullanıcıyla iki instance’a login olun — session’un Redis’te tutulduğunu ve her iki instance’ta da geçerli olduğunu gözlemleyin.</li>
        <li><span class="step">4.</span> Aynı anda iki farklı istemciden <code>POST /buy</code> çağrısı yapın — distributed lock sayesinde race condition olmadığını, stok tutarlı kaldığını gözlemleyin.</li>
        <li><span class="step">5.</span> Redis CLI ile session ve lock verilerini inceleyin:
            <div class="code-block">
redis-cli
KEYS *
HGETALL "spring:session:sessions:xxxx"
            </div>
        </li>
    </ul>

    <div class="performance-impact">
        <strong>PERFORMANS GÖZLEMİ:</strong> Distributed lock olmadan 100 eşzamanlı istekte stok -50 gibi tutarsız bir değere düşerken, distributed lock ile stok 0’dan aşağıya inmez ve tutarlı kalır. Eklenen ortalama gecikme: ~5ms.
    </div>
</div>

<div class="important">
    <strong>EĞİTMEN NOTU:</strong> Clustered ortamlarda performans optimizasyonu, sadece kod değil, mimari kararlarla da sağlanır. Session yönetimi, distributed lock, cache stratejileri ve network optimizasyonları bu kararların en kritikleridir. Öğrencilerin “scale-out” zihniyetini benimsemesi gerekir.
</div>

</body>
</html>