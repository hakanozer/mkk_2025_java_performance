<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bölüm 7 – Concurrency and Multi-Threading Performance</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f9f9f9;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        h1 {
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            background-color: #ecf0f1;
            padding: 10px;
            border-left: 5px solid #3498db;
            margin-top: 30px;
        }
        .slide-title {
            font-weight: bold;
            color: #e74c3c;
            margin-top: 25px;
        }
        .highlight {
            background-color: #fffde7;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        .performance-impact {
            background-color: #e8f5e9;
            padding: 15px;
            border-left: 4px solid #4caf50;
            margin: 20px 0;
        }
        .before-after {
            display: flex;
            gap: 20px;
            margin: 30px 0;
        }
        .before, .after {
            flex: 1;
            padding: 20px;
            border-radius: 8px;
        }
        .before {
            background-color: #ffebee;
            border: 1px solid #ef9a9a;
        }
        .after {
            background-color: #e8f5e9;
            border: 1px solid #a5d6a7;
        }
        .code-block {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            margin: 15px 0;
        }
        .note {
            background-color: #e3f2fd;
            padding: 15px;
            border-left: 4px solid #2196f3;
            margin: 20px 0;
        }
        ul, ol {
            margin: 15px 0;
            padding-left: 20px;
        }
        li {
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <h1>Bölüm 7 – Concurrency and Multi-Threading Performance</h1>
    
    <div class="slide-title">📑 Slide Başlıkları</div>
    <ul>
        <li>Java Concurrency API tuzakları</li>
        <li>Thread pools & ExecutorService tuning</li>
        <li>Spring Boot @Async thread pool config</li>
        <li>Parallel Streams & ForkJoin framework</li>
        <li>Distributed messaging’de concurrency sorunları</li>
    </ul>

    <h2>Java Concurrency API Tuzakları</h2>
    <p>Java'da eşzamanlılık API'leri güçlü olsa da, yanlış kullanıldığında performansı ciddi şekilde etkileyebilir. En sık karşılaşılan tuzaklar:</p>
    <ul>
        <li><strong>Thread yaratma maliyeti:</strong> Her istek için yeni thread oluşturmak, sistem kaynaklarını tüketir ve GC baskısını artırır.</li>
        <li><strong>Lock contention:</strong> Aşırı kilit kullanımı thread'leri bloke eder, CPU idle kalır.</li>
        <li><strong>Deadlock ve livelock:</strong> Thread'ler birbirini bekler hale gelir, sistem donar.</li>
        <li><strong>Yanlış synchronized kullanımı:</strong> Gereksiz geniş scope'larda synchronized kullanımı performansı düşürür.</li>
        <li><strong>ThreadLocal sızıntıları:</strong> ThreadLocal değişkenlerin temizlenmemesi memory leak'e neden olur.</li>
    </ul>

    <div class="performance-impact">
        <strong>PERFORMANS ETKİSİ:</strong> Bu tuzaklar, yüksek yük altında sistemde 10x-100x performans düşüşüne neden olabilir. Thread yaratma maliyeti, her thread için 1MB stack alanı ve context switching overhead'i getirir.
    </div>

    <h2>Thread Pools & ExecutorService Tuning</h2>
    <p>Thread pool'lar, thread yaratma maliyetini azaltmak ve sistem kaynaklarını kontrol altında tutmak için kritik öneme sahiptir.</p>
    
    <div class="highlight">
        <strong>ÖNEMLİ VURGU:</strong> Thread pool boyutu, CPU core sayısı ve I/O yoğunluğu dikkate alınarak optimize edilmelidir. 
        <br><br>
        <strong>Formül:</strong> 
        <br>
        CPU-bound: <code>threadPoolSize = CPU cores + 1</code>
        <br>
        I/O-bound: <code>threadPoolSize = CPU cores * (1 + waitTime/computeTime)</code>
    </div>

    <div class="before-after">
        <div class="before">
            <h3>ÖNCE: Varsayılan Thread Pool</h3>
            <div class="code-block">
// Spring Boot varsayılan @Async thread pool
// corePoolSize: 8, maxPoolSize: Integer.MAX_VALUE
// Bu, yüksek yükte sistem çökmesine neden olabilir!
            </div>
            <p><strong>Performans Sonucu:</strong> 50 eşzamanlı istekte 15 thread yaratıldı, 35'i kuyrukta bekledi, ortalama yanıt süresi: 4.2s</p>
        </div>
        <div class="after">
            <h3>SONRA: Optimize Edilmiş Thread Pool</h3>
            <div class="code-block">
@Configuration
@EnableAsync
public class AsyncConfig {
    
    @Bean(name = "taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);           // CPU core sayısına göre
        executor.setMaxPoolSize(50);            // Beklenen max eşzamanlı istek
        executor.setQueueCapacity(100);         // Kuyruk boyutu
        executor.setThreadNamePrefix("Async-");
        executor.setRejectedExecutionHandler(
            new ThreadPoolExecutor.CallerRunsPolicy()); // Reddetme stratejisi
        executor.initialize();
        return executor;
    }
}
            </div>
            <p><strong>Performans Sonucu:</strong> 50 eşzamanlı istekte 50 thread aktif, ortalama yanıt süresi: 1.1s (%74 iyileşme)</p>
        </div>
    </div>

    <h2>Spring Boot @Async Thread Pool Config</h2>
    <p>@Async annotation'ı, metotların ayrı bir thread'de çalışmasını sağlar. Ancak varsayılan konfigürasyon performans için uygun değildir.</p>
    
    <div class="code-block">
@Service
public class AsyncService {
    
    @Async("taskExecutor") // Özel thread pool belirtildi
    public CompletableFuture<String> processAsync(Long id) {
        // Uzun süren işlem
        return CompletableFuture.completedFuture("Result for " + id);
    }
}
    </div>

    <div class="performance-impact">
        <strong>PERFORMANS ETKİSİ:</strong> Doğru konfigüre edilmiş @Async, I/O yoğun operasyonlarda (veritabanı, REST çağrıları) 3-5x performans artışı sağlar. Yanlış konfigürasyon ise sistem çökmesine neden olabilir.
    </div>

    <h2>Parallel Streams & ForkJoin Framework</h2>
    <p>Parallel streams, büyük veri setlerinde işlemleri paralel olarak çalıştırarak performansı artırabilir. Ancak küçük veri setlerinde overhead yaratır.</p>
    
    <div class="highlight">
        <strong>ÖNEMLİ VURGU:</strong> Parallel stream'ler sadece aşağıdaki durumlarda kullanılmalıdır:
        <ul>
            <li>Veri seti 10.000+ elemanlı</li>
            <li>Her eleman üzerinde yapılan işlem CPU yoğun (heavy computation)</li>
            <li>İşlem stateless ve side-effect free</li>
        </ul>
    </div>

    <div class="before-after">
        <div class="before">
            <h3>ÖNCE: Sequential Stream</h3>
            <div class="code-block">
List<User> users = userRepository.findAll();
List<UserDTO> dtos = users.stream()
    .map(this::convertToDTO)  // JSON parse benzeri işlem
    .collect(Collectors.toList());
            </div>
            <p><strong>Performans Sonucu:</strong> 50.000 kullanıcı için: 8.7s</p>
        </div>
        <div class="after">
            <h3>SONRA: Parallel Stream</h3>
            <div class="code-block">
List<User> users = userRepository.findAll();
List<UserDTO> dtos = users.parallelStream()
    .map(this::convertToDTO)  // JSON parse benzeri işlem
    .collect(Collectors.toList());
            </div>
            <p><strong>Performans Sonucu:</strong> 50.000 kullanıcı için: 2.3s (%74 iyileşme)</p>
        </div>
    </div>

    <div class="note">
        <strong>UYARI:</strong> 1.000 kullanıcı için test yapıldığında:
        <br>
        Sequential: 0.17s → Parallel: 0.29s (%70 KÖTÜLEŞME!)
        <br>
        Küçük veri setlerinde parallel stream kullanmayın!
    </div>

    <h2>Distributed Messaging’de Concurrency Sorunları</h2>
    <p>Dağıtık sistemlerde mesajlaşma (Kafka, RabbitMQ) sırasında concurrency sorunları:</p>
    <ul>
        <li><strong>Consumer thread sayısı:</strong> Partition sayısından fazla consumer thread açmak faydasızdır.</li>
        <li><strong>Message ordering:</strong> Paralel işleme sırasında mesaj sırası karışabilir.</li>
        <li><strong>Idempotency:</strong> Aynı mesajın birden fazla işlenmesi sistemi bozabilir.</li>
        <li><strong>Backpressure:</strong> Üretici tüketiciyi geçerse sistem çöker.</li>
    </ul>

    <div class="performance-impact">
        <strong>PERFORMANS ETKİSİ:</strong> Doğru konfigürasyon ile mesaj işleme hızı 10x artırılabilir. Yanlış konfigürasyon ile sistem çöker veya veri tutarsızlığı oluşur.
    </div>

    <h2>💻 Demo Senaryosu 1: @Async ile 50 Eşzamanlı REST Çağrısı</h2>
    <p>Spring Boot uygulamasında 50 eşzamanlı REST çağrısını @Async ile işleyip thread pool tuning yapacağız.</p>
    
    <div class="code-block">
@RestController
public class AsyncController {
    
    @Autowired
    private AsyncService asyncService;
    
    @GetMapping("/async/{id}")
    public CompletableFuture<String> asyncCall(@PathVariable Long id) {
        return asyncService.processAsync(id);
    }
}

@Service
public class AsyncService {
    
    @Async("taskExecutor")
    public CompletableFuture<String> processAsync(Long id) {
        try {
            // Simüle edilmiş REST çağrısı
            Thread.sleep(1000); // 1 sn bekleme
            return CompletableFuture.completedFuture("Processed: " + id);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
    }
}
    </div>

    <div class="highlight">
        <strong>JMeter Test Senaryosu:</strong>
        <ul>
            <li>50 eşzamanlı kullanıcı</li>
            <li>Her biri 5 istek gönderiyor</li>
            <li>Toplam 250 istek</li>
        </ul>
        
        <strong>Thread Pool Konfigürasyonları:</strong>
        <ol>
            <li>Varsayılan: core=8, max=Integer.MAX_VALUE → Ortalama süre: 6.8s, Hata oranı: %15</li>
            <li>Optimize: core=10, max=50, queue=100 → Ortalama süre: 1.9s, Hata oranı: %0</li>
            <li>Aşırı optimize: core=50, max=50 → Ortalama süre: 1.5s, CPU kullanımı: %95</li>
        </ol>
    </div>

    <h2>💻 Demo Senaryosu 2: Parallel Stream vs Normal Loop ile JSON Parse Performans Kıyaslaması</h2>
    <p>50.000 JSON nesnesinin parse edilmesi sırasında parallel stream ve normal loop performans karşılaştırması.</p>
    
    <div class="code-block">
@Component
public class JsonPerformanceTest {
    
    // 50.000 JSON string içeren liste
    private List<String> jsonStrings = generateJsonStrings(50000);
    
    // Sequential processing
    public void testSequential() {
        long start = System.currentTimeMillis();
        List<User> users = jsonStrings.stream()
            .map(this::parseJson)  // Jackson ObjectMapper kullanarak
            .collect(Collectors.toList());
        long end = System.currentTimeMillis();
        System.out.println("Sequential: " + (end - start) + "ms");
    }
    
    // Parallel processing
    public void testParallel() {
        long start = System.currentTimeMillis();
        List<User> users = jsonStrings.parallelStream()
            .map(this::parseJson)
            .collect(Collectors.toList());
        long end = System.currentTimeMillis();
        System.out.println("Parallel: " + (end - start) + "ms");
    }
    
    private User parseJson(String json) {
        try {
            return objectMapper.readValue(json, User.class);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
    </div>

    <div class="performance-impact">
        <strong>PERFORMANS SONUÇLARI (8-core CPU):</strong>
        <ul>
            <li>Sequential: 8.723ms</li>
            <li>Parallel: 2.341ms (%73 iyileşme)</li>
            <li>CPU Kullanımı: Sequential %12 → Parallel %85</li>
        </ul>
        
        <strong>ÖNEMLİ NOT:</strong> ObjectMapper thread-safe değildir! Parallel stream'de her thread için ayrı ObjectMapper instance'ı kullanılmalıdır.
    </div>

    <div class="note">
        <h3>Öğrencilere Pratik Tavsiyeler:</h3>
        <ol>
            <li>Her zaman ölçümlerle başla (JMeter, Gatling)</li>
            <li>Thread pool'ları workload'e göre ayarla</li>
            <li>Parallel stream'leri sadece büyük veri setlerinde ve CPU yoğun işlemlerde kullan</li>
            <li>@Async kullanırken mutlaka özel thread pool tanımla</li>
            <li>Concurrency sorunlarını çözmek için stress test yap</li>
            <li>ThreadLocal'leri temizlemeyi unutma</li>
        </ol>
    </div>

    <h2>Ölçüm Araçları</h2>
    <p>Performans ölçümü ve tuning için kullanılacak araçlar:</p>
    <ul>
        <li><strong>JMeter:</strong> Yük testi için</li>
        <li><strong>VisualVM:</strong> Thread ve memory analizi</li>
        <li><strong>Spring Boot Actuator:</strong> Thread pool metrikleri</li>
        <li><strong>AsyncProfiler:</strong> CPU ve lock analizi</li>
        <li><strong>JConsole:</strong> JVM monitörizasyonu</li>
    </ul>

    <div class="highlight">
        <strong>Spring Boot Actuator ile Thread Pool Monitorizasyonu:</strong>
        <br>
        <code>management.endpoint.metrics.enabled=true</code>
        <br>
        <code>management.endpoints.web.exposure.include=metrics,health,info</code>
        <br>
        <code>GET /actuator/metrics/process.uptime</code>
        <br>
        <code>GET /actuator/metrics/jvm.threads.live</code>
    </div>

    <div class="performance-impact">
        <h3>Genel Performans İyileştirme Özet Tablosu</h3>
        <table border="1" cellpadding="10" style="width:100%; border-collapse: collapse;">
            <tr>
                <th>Teknik</th>
                <th>Önce</th>
                <th>Sonra</th>
                <th>İyileşme</th>
                <th>Riskler</th>
            </tr>
            <tr>
                <td>@Async Thread Pool</td>
                <td>8 core, unlimited max</td>
                <td>10 core, 50 max</td>
                <td>%74 daha hızlı</td>
                <td>Queue dolarsa reject</td>
            </tr>
            <tr>
                <td>Parallel Stream</td>
                <td>Sequential stream</td>
                <td>Parallel stream</td>
                <td>%73 daha hızlı</td>
                <td>Küçük veride kötü</td>
            </tr>
            <tr>
                <td>ExecutorService</td>
                <td>Her istekte yeni thread</td>
                <td>Thread pool reuse</td>
                <td>%90 memory tasarrufu</td>
                <td>Pool boyutu yanlışsa</td>
            </tr>
        </table>
    </div>

    <div class="note">
        <h3>Son Vurgu:</h3>
        <p>Concurrency ve multi-threading, performans optimizasyonunun en güçlü silahıdır ama aynı zamanda en tehlikelisidir. Her optimizasyon mutlaka ölçümlerle doğrulanmalı, production ortamına gradual olarak çıkarılmalı ve monitoring ile takip edilmelidir. "Premature optimization is the root of all evil" - Donald Knuth</p>
    </div>
</body>
</html>